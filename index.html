<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bingo Card Scanner v2.3.5 (PWA)</title>
  <meta name="theme-color" content="#0b4aa2" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icons/icon-192.png" />
  <link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png" />
  <style>
    :root{
      --bg:#0b1220; --panel:#111b2d; --muted:#9fb0d0; --text:#e9f0ff;
      --accent:#4da3ff; --good:#37d67a; --warn:#ffcc66; --bad:#ff5a6a;
      --card:#0f1930; --line:rgba(255,255,255,.10);
    }
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; background:linear-gradient(180deg,#070b14,#0b1220); color:var(--text);}
    header{position:sticky; top:0; z-index:10; background:rgba(11,18,32,.88); backdrop-filter: blur(10px); border-bottom:1px solid var(--line);}
    .wrap{max-width:1100px; margin:0 auto; padding:14px 14px;}
    h1{margin:0; font-size:18px; letter-spacing:.2px;}
    .sub{color:var(--muted); font-size:13px; margin-top:4px;}
    .grid{display:grid; gap:12px; grid-template-columns: 410px 1fr;}
    @media (max-width: 940px){ .grid{grid-template-columns:1fr;} }

    .panel{background:rgba(17,27,45,.78); border:1px solid var(--line); border-radius:14px; padding:12px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button, input{
      border-radius:12px; border:1px solid var(--line);
      background:#0c162a; color:var(--text);
      padding:10px 12px; font-size:14px;
    }
    button{cursor:pointer}
    button.primary{background:linear-gradient(180deg,#187bff,#0a55c6); border-color:rgba(255,255,255,.14);}
    button.ghost{background:transparent}
    button:disabled{opacity:.55; cursor:not-allowed}
    input[type="number"]{width:120px}
    .pill{font-size:12px; padding:5px 10px; border:1px solid var(--line); border-radius:999px; color:var(--muted); background:rgba(12,22,42,.6);}
    .status{font-size:13px; color:var(--muted); line-height:1.35}
    .status b{color:var(--text)}
    .thumbs{display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; margin-top:10px;}
    .thumb{
      background:rgba(15,25,48,.7);
      border:1px solid var(--line);
      border-radius:12px; padding:8px;
      display:flex; flex-direction:column; gap:6px;
      cursor:pointer;
    }
    .thumb.active{outline:2px solid rgba(77,163,255,.65)}
    .thumb img{width:100%; aspect-ratio: 4/3; object-fit:cover; border-radius:10px; border:1px solid var(--line);}
    .thumb .tmeta{display:flex; justify-content:space-between; gap:6px; color:var(--muted); font-size:12px;}
    .canvasWrap{position:relative; width:100%; border-radius:14px; overflow:hidden; border:1px solid var(--line); background:#081025;}
    canvas{display:block; width:100%; height:auto;}
    .overlay{position:absolute; inset:0;}
    .cropRect{
      position:absolute; border:2px dashed rgba(255,255,255,.75);
      background:rgba(77,163,255,.10);
      box-shadow: 0 0 0 9999px rgba(0,0,0,.35);
      border-radius:10px;
      touch-action:none;
    }
    .handle{
      position:absolute; width:24px; height:24px; border-radius:50%;
      background:rgba(255,255,255,.95);
      border:2px solid rgba(77,163,255,.9);
      box-shadow:0 4px 14px rgba(0,0,0,.4);
      transform:translate(-50%,-50%);
      touch-action:none;
    }
    .hint{color:var(--muted); font-size:12px; margin-top:8px}
    .hr{height:1px; background:var(--line); margin:12px 0;}
    .board{display:grid; grid-template-columns:repeat(5, 1fr); gap:8px; margin-top:10px;}
    .cell{
      border:1px solid var(--line);
      background:rgba(15,25,48,.7);
      border-radius:12px;
      min-height:56px;
      display:flex; align-items:center; justify-content:center;
      font-weight:700; font-size:18px;
      position:relative;
      user-select:none;
    }
    .cell.free{color:rgba(255,255,255,.85); font-size:14px; font-weight:800; letter-spacing:.6px;}
    .cell.marked{background:rgba(55,214,122,.18); border-color:rgba(55,214,122,.55);}
    .cell.bad{background:rgba(255,90,106,.14); border-color:rgba(255,90,106,.55);}
    .cell.sus{background:rgba(255,204,102,.12); border-color:rgba(255,204,102,.55);}
    .cell.editable{cursor:pointer;}
    .cell.editable:hover{border-color:rgba(77,163,255,.7);}
    .cell small{position:absolute; bottom:6px; right:8px; font-size:10px; color:var(--muted); font-weight:600;}
    .history{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
    .chip{
      padding:7px 10px; border-radius:999px;
      border:1px solid var(--line);
      background:rgba(12,22,42,.7);
      color:var(--text);
      font-size:13px;
      cursor:pointer;
    }
    .chip:hover{border-color:rgba(77,163,255,.6)}
    .footer{color:var(--muted); font-size:12px; margin-top:10px}
    .spinner{
      display:inline-block; width:14px; height:14px; border-radius:50%;
      border:2px solid rgba(255,255,255,.25); border-top-color:rgba(255,255,255,.9);
      animation:spin 1s linear infinite; vertical-align:-2px; margin-right:8px;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    #installBar{
      display:none;
      margin-top:10px;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:rgba(12,22,42,.7);
      color:var(--muted);
    }
    #warnBanner{margin-top:10px;padding:10px 12px;border:1px solid var(--line);border-radius:12px;
      background:rgba(255,204,102,.10);color:var(--muted);font-size:12px;line-height:1.35}
    #warnBanner b{color:var(--text)}
    #toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:rgba(12,22,42,.92);border:1px solid var(--line);color:var(--text);
      padding:10px 12px;border-radius:999px;max-width:92vw;display:none;z-index:9999;font-size:13px}
  
        .stackCard{
          margin-bottom:16px;
          padding:10px;
          border:1px solid var(--line);
          border-radius:14px;
          background:rgba(15,25,48,.7);
        }
        .stackCard canvas{
          width:100%;
          height:auto;
          border-radius:12px;
          border:1px solid var(--line);
        }
        .stackLabel{
          font-size:13px;
          color:var(--muted);
          margin-bottom:6px;
          display:flex; justify-content:space-between; gap:10px; align-items:center;
        }
.stackLabel b{color:var(--text)}
.stackBoard{display:grid; grid-template-columns:repeat(5, 1fr); gap:8px;}
.stackBoard .cell{min-height:52px;}
        
    .playStackCard{margin:12px 0; padding:10px; border:1px solid var(--line); border-radius:14px; background:rgba(15,25,48,.65);}
    .playStackHdr{display:flex; justify-content:space-between; align-items:center; gap:10px; font-size:13px; color:var(--muted); margin-bottom:8px;}
    .playStackHdr b{color:var(--text)}
    .playStackBoard{display:grid; grid-template-columns:repeat(5,1fr); gap:8px;}
    .playStackBoard .cell{min-height:48px;}
    @media (max-width:520px){ .playStackBoard .cell{min-height:42px;} }
  
  /* ===== Caller Bar Visibility Boost (v2.3.5) ===== */
  #callerBar{
    background: rgba(20, 40, 85, 0.92) !important;
    border: 2px solid rgba(120, 200, 255, 0.95) !important;
    box-shadow: 0 10px 24px rgba(0,0,0,0.35);
  }
  #callerBar .status{
    font-size: 18px;
    font-weight: 800;
    color: #f2f7ff;
  }
  #callerBar input{
    font-size: 18px;
    padding: 10px 12px;
    min-width: 120px;
    border-radius: 12px;
    border: 2px solid rgba(120, 200, 255, 0.7);
    background: rgba(7, 14, 26, 0.85);
    color: #f2f7ff;
  }
  #callerBar button{
    font-size: 18px;
    padding: 10px 14px;
    border-radius: 12px;
  }
  #callerBar .hint{
    font-size: 16px;
    color: rgba(235,245,255,0.95);
    font-weight: 700;
  }
  #callerBar .history{
    gap: 10px;
  }
  #callerBar .chip{
    font-size: 18px;
    padding: 10px 12px;
    border-radius: 999px;
    border: 2px solid rgba(120, 200, 255, 0.8);
    background: rgba(10, 22, 44, 0.9);
    color: #f2f7ff;
  }
  #callerBar .chip:hover{
    filter: brightness(1.2);
  }
  @media (max-width: 520px){
    #callerBar .status, #callerBar input, #callerBar button, #callerBar .chip{ font-size: 17px; }
    #callerBar input{ min-width: 96px; }
  }

</style>
        
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Bingo Card Scanner v2.3.5 (PWA)</h1>
      <div class="sub">Scan bingo cards (camera) + OCR. Enter called numbers by typing or voice. Save/recall cards.</div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <!-- LEFT -->
      <section class="panel">
        <div class="row">
          <button class="primary" id="btnCapture">üì∑ Scan Card</button>
          <button class="ghost" id="btnClearGame">New Game</button>
          <button class="ghost" id="btnClearAll">Reset</button>
          <span class="pill" id="pillCount">0 cards</span>
        </div>

        <div id="warnBanner">
          <b>Use at your own risk:</b> OCR accuracy varies by device, lighting, camera angle, and card design.
          Always verify highlighted numbers yourself.
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="btnSaveSession" class="ghost">üíæ Save Cards</button>
          <button id="btnLoadSession" class="ghost">üìÇ Recall Cards</button>
          <button id="btnClearSaved" class="ghost">üßπ Clear Saved</button>
          <span class="pill" id="pillSaved">saved: ‚Äî</span>
        </div>

        <div id="installBar" class="row" style="justify-content:space-between;">
          <div>Install this app for faster access.</div>
          <button id="btnInstall" class="primary">Install</button>
        </div>
        <div class="hr"></div>

        <div class="status" id="statusBox">
          <b>Status:</b> Ready. Scan a card to begin. (Call numbers on the right.)
        </div>

        <div class="thumbs" id="thumbs"></div>

        <div class="footer">¬© 2026 Angel Bear / Glen Carruthers. All rights reserved.</div>
      </section>

      <!-- RIGHT -->
      <section class="panel">
        <div class="row" style="justify-content:space-between;">
  <div class="status"><b>View:</b> <span id="selLabel">Single</span> <span class="pill" id="pillCalled" style="margin-left:8px">0 called</span></div>
  <div class="row">
    <button id="btnStackView" class="ghost">üìã Stacked Boards</button>
    <button id="btnCropMode" class="ghost" disabled>Crop</button>
    <button id="btnReadOCR" class="primary" disabled>Read Numbers (OCR)</button>
    <button id="btnRetryOCR" class="ghost" disabled>Retry Missing</button>
  </div>
</div>
<div class="status" id="stackTitle" style="display:none; margin-top:10px;"><b>Playing cards:</b> stacked 5√ó5 grids</div>
        <div id="stackContainer" style="display:none; margin-top:10px;"></div>


        <div class="canvasWrap" id="canvasWrap" style="margin-top:10px;">
  <canvas id="view"></canvas>
  <div class="overlay" id="overlay"></div>
</div>

        <div class="hint">
          Workflow: Scan ‚Üí Crop (adjust box) ‚Üí ‚ÄúRead Numbers (OCR)‚Äù ‚Üí Type or speak called numbers.
          <br/>Tip: Tap any square to correct it. ‚ÄúRetry Missing‚Äù tries only blank cells.
          <br/>Offline note: the app shell caches offline; the OCR library loads from a CDN (first run needs internet).
        </div>

        <div class="hr"></div>


        
        <div class="panel" style="padding:12px; margin-top:10px; background:rgba(12,22,42,.35); border-style:dashed;">
          <div class="row">
            <label class="status" style="display:flex; gap:8px; align-items:center;">
              Called #
              <input id="calledNum" type="number" inputmode="numeric" min="1" max="75" placeholder="1‚Äì75" />
            </label>
            <button id="btnCall" class="primary">Mark</button>
            <button id="btnVoice" class="ghost">üé§ Voice</button>
            <button id="btnUndo" class="ghost" disabled>Undo</button>
          </div>
          <div class="hint" style="margin-top:8px">Tip: Tap a number in the list to re-apply it. Voice works best in Chrome/Edge.</div>
          <div class="history" id="history"></div>
        </div>
        <div class="hr"></div>
        <div class="status" id="playStackTitle"><b>All cards:</b> scroll to review highlights</div>
        <div id="playStack" style="margin-top:10px;"></div>

        


        <div id="singleBoardArea">
        <div class="status"><b>Detected 5√ó5 grid:</b> <span style="color:var(--muted)">Tap any square to correct it.</span></div>
        <div class="board" id="board"></div>
        </div>
      </section>
    </div>
  </main>

  <!-- IMPORTANT: not display:none (some mobile browsers block .click() on fully hidden inputs) -->
  <input id="cameraInput" type="file" accept="image/*" capture="environment"
         style="position:fixed;left:-9999px;top:0;width:1px;height:1px;opacity:0;" />

  <script src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

  <div id="toast"></div>

  <script>
    // ===== PWA service worker =====
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./service-worker.js").catch(()=>{});
      });
    }

    // Install prompt
    let deferredPrompt = null;
    const installBar = document.getElementById("installBar");
    const btnInstall = document.getElementById("btnInstall");
    window.addEventListener("beforeinstallprompt", (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBar.style.display = "flex";
    });
    btnInstall?.addEventListener("click", async () => {
      if(!deferredPrompt) return;
      deferredPrompt.prompt();
      await deferredPrompt.userChoice;
      deferredPrompt = null;
      installBar.style.display = "none";
    });

    // ===== Helpers =====
    const $ = sel => document.querySelector(sel);
    const el = (tag, props={}) => Object.assign(document.createElement(tag), props);
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function setStatus(html){ $("#statusBox").innerHTML = `<b>Status:</b> ${html}`; }

    // Show JS errors on-screen (helps on mobile)
    window.addEventListener("error", (e) => {
      const msg = (e && e.message) ? e.message : "Unknown error";
      setStatus(`<span style="color:var(--bad)"><b>App error:</b></span> ${msg}`);
    });

    // ===== Toast =====
    const toastEl = document.getElementById("toast");
    function toast(msg){
      if(!toastEl) return;
      toastEl.textContent = msg;
      toastEl.style.display = "block";
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>{ toastEl.style.display="none"; }, 1800);
    }

    // ===== Back button handling (prevent accidental app close) =====
    (function(){
      try{
        history.pushState({app:true}, "");
        window.addEventListener("popstate", ()=>{
          // Close crop UI first if open
          const overlay = document.getElementById("overlay");
          if(overlay && overlay.children.length){
            hideCropUI();
            toast("Closed crop tool");
            history.pushState({app:true}, "");
            return;
          }
          toast("Back disabled to prevent closing. Use Home/Recents to exit.");
          history.pushState({app:true}, "");
        });
      } catch(_) {}
    })();

    // ===== IndexedDB persistence (save/recall cards) =====
    const DB_NAME = "bingoScanDB";
    const DB_VER  = 1;
    const STORE   = "sessions";
    const SESSION_KEY = "default";

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(STORE)){
            db.createObjectStore(STORE);
          }
        };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }

    async function dbSet(key, value){
      const db = await openDB();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).put(value, key);
        tx.oncomplete = ()=>{ db.close(); resolve(true); };
        tx.onerror = ()=>{ db.close(); reject(tx.error); };
      });
    }

    async function dbGet(key){
      const db = await openDB();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, "readonly");
        const req = tx.objectStore(STORE).get(key);
        req.onsuccess = ()=>{ const v=req.result; db.close(); resolve(v); };
        req.onerror = ()=>{ db.close(); reject(req.error); };
      });
    }

    async function dbDel(key){
      const db = await openDB();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, "readwrite");
        tx.objectStore(STORE).delete(key);
        tx.oncomplete = ()=>{ db.close(); resolve(true); };
        tx.onerror = ()=>{ db.close(); reject(tx.error); };
      });
    }

    // ===== App state =====
    const state = { cards: [], selectedId: null, calledHistory: [] };

    function serializeState(){
      return {
        version: "1.7",
        savedAt: new Date().toISOString(),
        calledHistory: state.calledHistory,
        cards: state.cards.map(c => ({
          id: c.id,
          imgDataURL: c.imgDataURL,
          crop: c.crop,
          grid: c.grid,
          marked: Array.from(c.marked || []),
        })),
        selectedId: state.selectedId
      };
    }

    function hydrateState(saved){
      state.calledHistory = Array.isArray(saved.calledHistory) ? saved.calledHistory : [];
      state.cards = Array.isArray(saved.cards) ? saved.cards.map(c => ({
        id: c.id,
        imgDataURL: c.imgDataURL,
        crop: c.crop || null,
        grid: c.grid || null,
        marked: new Set(Array.isArray(c.marked) ? c.marked : []),
      })) : [];
      state.selectedId = saved.selectedId || (state.cards[0]?.id ?? null);
    }

    async function updateSavedPill(){
      try{
        const saved = await dbGet(SESSION_KEY);
        const pill = document.getElementById("pillSaved");
        if(!pill) return;
        if(saved && saved.savedAt){
          const d = new Date(saved.savedAt);
          pill.textContent = "saved: " + d.toLocaleString();
        } else {
          pill.textContent = "saved: ‚Äî";
        }
      } catch(_) {}
    }

    async function saveSession(silent=false){
      try{
        await dbSet(SESSION_KEY, serializeState());
        await updateSavedPill();
        if(!silent) toast("Cards saved");
      } catch(e){
        setStatus(`<span style="color:var(--warn)"><b>Save failed:</b></span> ${e?.message||e}`);
      }
    }

    async function loadSession(){
      try{
        const saved = await dbGet(SESSION_KEY);
        if(!saved || !saved.cards){
          toast("No saved cards");
          return;
        }
        hydrateState(saved);
        refreshThumbs();
        refreshHistory();
    try{ renderPlayStack(); }catch(_){ }
        renderBoard();
        if(state.selectedId) await selectCard(state.selectedId);
        else drawEmpty();
        toast("Cards recalled");
      } catch(e){
        setStatus(`<span style="color:var(--warn)"><b>Recall failed:</b></span> ${e?.message||e}`);
      }
    }

    async function clearSaved(){
      try{
        await dbDel(SESSION_KEY);
        await updateSavedPill();
        toast("Saved cards cleared");
      } catch(e){
        setStatus(`<span style="color:var(--warn)"><b>Clear failed:</b></span> ${e?.message||e}`);
      }
    }

    // ===== Canvas + image =====
    const canvas = $("#view");
    const ctx = canvas.getContext("2d");
    let loadedImg = null;
    let imgNatural = { w:0, h:0 };

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const newW = Math.max(1, Math.round(rect.width * dpr));
      const newH = Math.max(1, Math.round(rect.width * 0.75 * dpr)); // keep a nice aspect
      if (canvas.width !== newW || canvas.height !== newH) {
        canvas.width = newW;
        canvas.height = newH;
      }
      return { cssW: rect.width, cssH: rect.height, dpr };
    }

    function drawEmpty(msg="No card selected."){
      resizeCanvasToDisplaySize();
      ctx.fillStyle="#081025";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle="rgba(255,255,255,.80)";
      ctx.font="18px system-ui";
      ctx.fillText(msg, 20, 34);
      ctx.fillStyle="rgba(255,255,255,.55)";
      ctx.font="13px system-ui";
      ctx.fillText("Scan a card on the left.", 20, 58);
    }

    function fitRect(w,h, W,H){
      const s = Math.min(W/w, H/h);
      const ww = Math.round(w*s), hh=Math.round(h*s);
      return { x: Math.round((W-ww)/2), y: Math.round((H-hh)/2), w: ww, h: hh, s };
    }

    function imageRectToCanvasRect(r, fit){
      const sx = fit.w / imgNatural.w;
      const sy = fit.h / imgNatural.h;
      return { x: fit.x + r.x*sx, y: fit.y + r.y*sy, w: r.w*sx, h: r.h*sy };
    }

    function fmtCardName(card){
      const idx = state.cards.findIndex(c => c.id === card.id);
      return `Card ${idx+1}`;
    }

    function countMarks(card){ return card.marked ? card.marked.size : 0; }

    function drawGridOverlay(card, cropCanvas){
      const cellW = cropCanvas.w / 5;
      const cellH = cropCanvas.h / 5;

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          if(r===2 && c===2) continue;
          const n = card.grid?.[r]?.[c];
          if(n == null) continue;
          if(card.marked && card.marked.has(String(n))){
            ctx.fillStyle = "rgba(55,214,122,.22)";
            ctx.fillRect(cropCanvas.x + c*cellW, cropCanvas.y + r*cellH, cellW, cellH);
          }
        }
      }

      ctx.strokeStyle = "rgba(255,255,255,.35)";
      ctx.lineWidth = 1;
      for(let i=0;i<=5;i++){
        ctx.beginPath();
        ctx.moveTo(cropCanvas.x + i*cellW, cropCanvas.y);
        ctx.lineTo(cropCanvas.x + i*cellW, cropCanvas.y + cropCanvas.h);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cropCanvas.x, cropCanvas.y + i*cellH);
        ctx.lineTo(cropCanvas.x + cropCanvas.w, cropCanvas.y + i*cellH);
        ctx.stroke();
      }

      ctx.strokeStyle = "rgba(77,163,255,.85)";
      ctx.lineWidth = 2;
      ctx.strokeRect(cropCanvas.x, cropCanvas.y, cropCanvas.w, cropCanvas.h);
    }

    function drawSelected(){
      resizeCanvasToDisplaySize();
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const card = state.cards.find(c=>c.id===state.selectedId);
      if(!card){ drawEmpty(); return; }
      const img = loadedImg;
      if(!img){ drawEmpty("Loading image‚Ä¶"); return; }

      const fit = fitRect(imgNatural.w, imgNatural.h, canvas.width, canvas.height);
      ctx.fillStyle="#081025";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, fit.x, fit.y, fit.w, fit.h);

      if(card.grid){
        const crop = card.crop || {x:0,y:0,w:imgNatural.w,h:imgNatural.h};
        const cropCanvas = imageRectToCanvasRect(crop, fit);
        drawGridOverlay(card, cropCanvas);
      }
    }

    async function loadImage(src){
      return new Promise((res, rej)=>{
        const im = new Image();
        im.onload = ()=>res(im);
        im.onerror = rej;
        im.src = src;
      });
    }

    async function loadSelectedImage(){
      const card = state.cards.find(c=>c.id===state.selectedId);
      if(!card){ loadedImg=null; return; }
      loadedImg = await loadImage(card.imgDataURL);
      imgNatural.w = loadedImg.naturalWidth;
      imgNatural.h = loadedImg.naturalHeight;
    }

    async function selectCard(id){
      state.selectedId = id;
      const card = state.cards.find(c=>c.id===id);
      $("#selLabel").textContent = card ? fmtCardName(card) : "None";
      refreshThumbs();
      await loadSelectedImage();
      renderBoard();
      drawSelected();
      try{ renderPlayStack(); }catch(_){ }
      hideCropUI();
    }

    function refreshThumbs(){
      const wrap = $("#thumbs");
      wrap.innerHTML = "";
      state.cards.forEach(card=>{
        const d = el("div", { className: "thumb" + (card.id===state.selectedId ? " active" : "") });
        d.append(
          el("img", { src: card.imgDataURL, alt:"card" }),
          (()=>{ const meta=el("div",{className:"tmeta"});
            meta.append(
              el("span",{textContent:fmtCardName(card)}),
              el("span",{textContent: card.grid ? `OCR ‚úì ¬∑ ${countMarks(card)} marks` : "OCR ‚Äî"})
            );
            return meta;
          })()
        );
        d.addEventListener("click", ()=>selectCard(card.id));
        wrap.appendChild(d);
      });
      $("#pillCount").textContent = `${state.cards.length} card${state.cards.length===1?"":"s"}`;
      $("#btnCropMode").disabled = !state.selectedId;
      $("#btnReadOCR").disabled = !state.selectedId;
      $("#btnRetryOCR").disabled = !state.selectedId;
    
      try{ renderPlayStack(); }catch(_){ }
}

    // ===== Crop UI (CSS-pixel based) =====
    const overlayEl = $("#overlay");
    let cropUI = null;

    function hideCropUI(){
      overlayEl.innerHTML = "";
      cropUI = null;
    }

    function showCropUI(){
      hideCropUI();
      const rect = el("div", { className:"cropRect" });
      overlayEl.appendChild(rect);

      const rbox = canvas.getBoundingClientRect();
      const cssW = rbox.width;
      const cssH = rbox.height;

      const pad = Math.round(Math.min(cssW, cssH) * 0.08);
      const r = { x: pad, y: pad, w: cssW - pad*2, h: cssH - pad*2 };

      const hTL = el("div",{className:"handle"});
      const hTR = el("div",{className:"handle"});
      const hBR = el("div",{className:"handle"});
      const hBL = el("div",{className:"handle"});
      rect.append(hTL,hTR,hBR,hBL);

      cropUI = { rectEl: rect, handles:[hTL,hTR,hBR,hBL], r };
      positionCropUI();

      attachHandleDrag(hTL, "tl");
      attachHandleDrag(hTR, "tr");
      attachHandleDrag(hBR, "br");
      attachHandleDrag(hBL, "bl");

      // Also allow dragging the whole rectangle
      rect.addEventListener("pointerdown", (ev)=>{
        if(ev.target.classList.contains("handle")) return;
        ev.preventDefault();
        const start = getPointer(ev);
        const r0 = {...cropUI.r};
        const move = (e)=>{
          const p = getPointer(e);
          const dx = p.x - start.x;
          const dy = p.y - start.y;
          const rbox = canvas.getBoundingClientRect();
          const cssW = rbox.width, cssH = rbox.height;
          cropUI.r.x = clamp(r0.x + dx, 0, cssW - r0.w);
          cropUI.r.y = clamp(r0.y + dy, 0, cssH - r0.h);
          positionCropUI();
        };
        const up = ()=>{ window.removeEventListener("pointermove", move); };
        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up, {once:true});
      });
    }

    function positionCropUI(){
      if(!cropUI) return;
      const {rectEl, handles, r} = cropUI;
      rectEl.style.left = r.x + "px";
      rectEl.style.top  = r.y + "px";
      rectEl.style.width  = r.w + "px";
      rectEl.style.height = r.h + "px";
      const corners = [{x:0,y:0},{x:r.w,y:0},{x:r.w,y:r.h},{x:0,y:r.h}];
      corners.forEach((p,i)=>{ handles[i].style.left=p.x+"px"; handles[i].style.top=p.y+"px"; });
    }

    function getPointer(ev){
      const rect=canvas.getBoundingClientRect();
      return { x: ev.clientX-rect.left, y: ev.clientY-rect.top };
    }

    function attachHandleDrag(handle, which){
      let dragging=false; let start=null;
      const onDown=(ev)=>{
        ev.preventDefault();
        dragging=true;
        const p=getPointer(ev);
        start={p, r:{...cropUI.r}};
        window.addEventListener("pointermove", onMove);
        window.addEventListener("pointerup", onUp, {once:true});
      };
      const onMove=(ev)=>{
        if(!dragging) return;
        const p=getPointer(ev);
        const dx=p.x-start.p.x, dy=p.y-start.p.y;
        const r0=start.r;
        let r={...cropUI.r};

        if(which==="tl"){ r.x=r0.x+dx; r.y=r0.y+dy; r.w=r0.w-dx; r.h=r0.h-dy; }
        if(which==="tr"){ r.y=r0.y+dy; r.w=r0.w+dx; r.h=r0.h-dy; }
        if(which==="br"){ r.w=r0.w+dx; r.h=r0.h+dy; }
        if(which==="bl"){ r.x=r0.x+dx; r.w=r0.w-dx; r.h=r0.h+dy; }

        const minSize=140;
        r.w=Math.max(minSize,r.w); r.h=Math.max(minSize,r.h);

        const box = canvas.getBoundingClientRect();
        r.x=clamp(r.x,0,box.width-r.w);
        r.y=clamp(r.y,0,box.height-r.h);

        cropUI.r=r;
        positionCropUI();
      };
      const onUp=()=>{ dragging=false; window.removeEventListener("pointermove", onMove); };
      handle.addEventListener("pointerdown", onDown);
    }

    $("#btnCropMode").addEventListener("click", ()=>{
      if(!state.selectedId) return;
      showCropUI();
      setStatus(`Crop mode: drag corners (or box) to fit the grid, then click <b>Read Numbers (OCR)</b>.`);
    });

    // ===== Board (tap-to-edit) =====
    function renderBoard(){
      const card = state.cards.find(c=>c.id===state.selectedId);
      const board = $("#board");
      board.innerHTML = "";
      if(!card){ board.innerHTML = `<div class="hint">No card selected.</div>`; return; }
      const grid = card.grid || Array.from({length:5}, ()=>Array(5).fill(null));
      const ranges = [[1,15],[16,30],[31,45],[46,60],[61,75]];

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          const cell = el("div", { className:"cell" });
          if(r===2 && c===2){
            cell.classList.add("free","marked");
            cell.textContent = "FREE";
            cell.appendChild(el("small",{textContent:"(center)"}));
          } else {
            const n = grid[r][c];
            cell.textContent = n==null ? "‚Äî" : String(n);
            cell.classList.add("editable");
            if(n!=null){
              const [lo,hi]=ranges[c];
              if(n<lo || n>hi) cell.classList.add("sus");
            }
            if(n!=null && card.marked && card.marked.has(String(n))) cell.classList.add("marked");
            if(n==null && card.grid) cell.classList.add("bad");

            cell.addEventListener("click", ()=>{
              const current = (grid[r][c]==null) ? "" : String(grid[r][c]);
              const val = prompt("Edit this square (leave blank to clear):", current);
              if(val === null) return;
              const vv = val.trim();
              let newNum = null;
              if(vv){
                const parsed = parseInt(vv,10);
                if(Number.isFinite(parsed) && parsed>=1 && parsed<=75) newNum = parsed;
              }
              card.grid[r][c] = newNum;

              // Rebuild marks for this card based on history
              card.marked = new Set();
              for(const s of state.calledHistory){
                markNumberOnCard(card, parseInt(s,10));
              }
              refreshThumbs();
              renderBoard();
              drawSelected();
              saveSession(true);
            });
          }
          board.appendChild(cell);
        }
      }
    
      try{ renderPlayStack(); }catch(_){ }
}

    // ===== Camera capture =====
    function fileToDataURL(file){
      return new Promise((res, rej)=>{
        const r = new FileReader();
        r.onload = ()=>res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

    $("#btnCapture").addEventListener("click", ()=>{
      const inp = $("#cameraInput");
      if(!inp) return;
      inp.value = "";
      try{ inp.click(); }
      catch(e){ setStatus(`<span style="color:var(--warn)"><b>Scan blocked.</b></span> Try Chrome/Edge, and ensure https.`); }
    });

    $("#cameraInput").addEventListener("change", async (e)=>{
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const dataURL = await fileToDataURL(f);
      const id = (crypto.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random()));
      state.cards.unshift({ id, imgDataURL:dataURL, crop:null, grid:null, marked:new Set() });
      setStatus(`Captured ${fmtCardName(state.cards[0])}. Next: <b>Crop</b> then <b>Read Numbers (OCR)</b>.`);
      $("#cameraInput").value = "";
      await selectCard(id);
      await saveSession(true);
    });

    // ===== OCR =====
    function markNumberOnCard(card, n){
      if(!card.grid) return;
      const s = String(n);
      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          if(r===2 && c===2) continue;
          const v = card.grid[r][c];
          if(v!=null && String(v)===s) card.marked.add(s);
        }
      }
    }

    async function runOCR(card, onlyMissing=false){
      if(!loadedImg) return;
      if(!cropUI && !card.crop){
        showCropUI();
        setStatus(`Crop box created. Adjust it if needed, then click <b>Read Numbers (OCR)</b> again.`);
        return;
      }

      // Determine crop in image coords
      let crop = card.crop;
      if(!crop){
        const rectCss = canvas.getBoundingClientRect();
        const cssW = rectCss.width;
        const cssH = rectCss.height;
        const fit = fitRect(imgNatural.w, imgNatural.h, cssW, cssH);
        const rC = cropUI.r;

        const sx = imgNatural.w / fit.w;
        const sy = imgNatural.h / fit.h;

        const imgX = (rC.x - fit.x) * sx;
        const imgY = (rC.y - fit.y) * sy;
        const imgW = rC.w * sx;
        const imgH = rC.h * sy;

        crop = {
          x: clamp(Math.round(imgX), 0, imgNatural.w-1),
          y: clamp(Math.round(imgY), 0, imgNatural.h-1),
          w: clamp(Math.round(imgW), 1, imgNatural.w),
          h: clamp(Math.round(imgH), 1, imgNatural.h),
        };
        crop.w = Math.min(crop.w, imgNatural.w - crop.x);
        crop.h = Math.min(crop.h, imgNatural.h - crop.y);
        card.crop = crop;
      }

      const off = document.createElement("canvas");
      off.width = crop.w; off.height = crop.h;
      const octx = off.getContext("2d");
      octx.drawImage(loadedImg, crop.x, crop.y, crop.w, crop.h, 0, 0, crop.w, crop.h);

      const grid = card.grid || Array.from({length:5}, ()=>Array(5).fill(null));
      const cellW = Math.floor(crop.w / 5);
      const cellH = Math.floor(crop.h / 5);

      const worker = await Tesseract.createWorker("eng", 1, { logger: ()=>{} });
      await worker.setParameters({ tessedit_char_whitelist: "0123456789", tessedit_pageseg_mode: "8" });

      const ranges = [[1,15],[16,30],[31,45],[46,60],[61,75]];
      const tries = [
        {t:140, inv:false},{t:155, inv:false},{t:170, inv:false},{t:190, inv:false},{t:210, inv:false},{t:170, inv:true},{t:210, inv:true}
      ];

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          if(r===2 && c===2) continue;
          if(onlyMissing && grid[r][c] != null) continue;

          const cx = c*cellW;
          const cy = r*cellH;
          const cw = (c===4) ? (crop.w - cx) : cellW;
          const ch = (r===4) ? (crop.h - cy) : cellH;

          // Padding to avoid borders/lines
          const padX = Math.round(cw * 0.08);
          const padY = Math.round(ch * 0.08);
          const sx0 = Math.min(cw-1, padX);
          const sy0 = Math.min(ch-1, padY);
          const sw0 = Math.max(1, cw - padX*2);
          const sh0 = Math.max(1, ch - padY*2);

          // Upscale
          const scale = 2;
          const cellCanvas = document.createElement("canvas");
          cellCanvas.width = sw0 * scale;
          cellCanvas.height = sh0 * scale;
          const cctx = cellCanvas.getContext("2d");
          cctx.imageSmoothingEnabled = true;
          cctx.imageSmoothingQuality = "high";
          cctx.drawImage(off, cx+sx0, cy+sy0, sw0, sh0, 0, 0, cellCanvas.width, cellCanvas.height);

          function thresholdCanvas(thresh, invert=false){
            const imgData = cctx.getImageData(0,0,cellCanvas.width,cellCanvas.height);
            const d = imgData.data;
            for(let i=0;i<d.length;i+=4){
              const gray = (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
              let v = gray > thresh ? 255 : 0;
              if(invert) v = 255 - v;
              d[i]=d[i+1]=d[i+2]=v;
            }
            cctx.putImageData(imgData,0,0);
          }

          async function readDigits(){
            const { data } = await worker.recognize(cellCanvas);
            const raw = (data.text || "").trim();
            const digits = raw.replace(/[^0-9]/g,"").trim();
            if(!digits) return null;
            const n = parseInt(digits, 10);
            if(!Number.isFinite(n) || n<1 || n>75) return null;
            return n;
          }

          let num = null;
          for(const tr of tries){
            thresholdCanvas(tr.t, tr.inv);
            num = await readDigits();
            if(num != null) break;
          }

          // Range sanity
          if(num != null){
            const [lo,hi] = ranges[c];
            if(num < lo || num > hi) num = null;
          }

          grid[r][c] = num;
        }
      }

      await worker.terminate();

      card.grid = grid;
      card.marked = new Set();
      for(const s of state.calledHistory){
        markNumberOnCard(card, parseInt(s,10));
      }

      refreshThumbs();
      renderBoard();
      drawSelected();
      hideCropUI();
      await saveSession(true);
    }

    $("#btnReadOCR").addEventListener("click", async ()=>{
      const card = state.cards.find(c=>c.id===state.selectedId);
      if(!card || !loadedImg) return;
      $("#btnReadOCR").disabled = true;
      $("#btnRetryOCR").disabled = true;
      $("#btnCropMode").disabled = true;
      setStatus(`<span class="spinner"></span>Reading numbers with OCR‚Ä¶`);
      try{
        await runOCR(card, false);
        setStatus(`OCR complete for <b>${fmtCardName(card)}</b>. Tap blanks to correct, or try <b>Retry Missing</b>.`);
      } catch(err){
        console.error(err);
        setStatus(`<span style="color:var(--bad)"><b>OCR failed.</b></span> Try better lighting and a straighter photo.`);
      } finally{
        $("#btnReadOCR").disabled = !state.selectedId;
        $("#btnRetryOCR").disabled = !state.selectedId;
        $("#btnCropMode").disabled = !state.selectedId;
      }
    });

    $("#btnRetryOCR").addEventListener("click", async ()=>{
      const card = state.cards.find(c=>c.id===state.selectedId);
      if(!card || !loadedImg) return;
      if(!card.grid || !card.crop){ toast("Run OCR first"); return; }
      $("#btnRetryOCR").disabled = true;
      setStatus(`<span class="spinner"></span>Retrying missing cells‚Ä¶`);
      try{
        await runOCR(card, true);
        setStatus(`Retry complete. Tap any remaining blanks to correct.`);
      } catch(err){
        console.error(err);
        setStatus(`<span style="color:var(--bad)"><b>Retry failed.</b></span> ${err?.message||err}`);
      } finally{
        $("#btnRetryOCR").disabled = !state.selectedId;
      }
    });

    // ===== Calling numbers (manual + voice) =====
    function applyCalledNumber(n){
      const s = String(n);
      if(!state.calledHistory.includes(s)){
        state.calledHistory.unshift(s);
        if(state.calledHistory.length>40) state.calledHistory.pop();
      }
      for(const card of state.cards){
        if(!card.marked) card.marked = new Set();
        markNumberOnCard(card, n);
      }
      refreshHistory();
      renderBoard();
      drawSelected();
      $("#btnUndo").disabled = state.calledHistory.length===0;
      setStatus(`Marked called number <b>${n}</b> across scanned cards.`);
      saveSession(true);
    
      try{ renderPlayStack(); }catch(_){ }
}

    $("#btnCall").addEventListener("click", ()=>{
      const n = parseInt($("#calledNum").value, 10);
      if(!Number.isFinite(n) || n<1 || n>75){
        setStatus(`<span style="color:var(--warn)"><b>Please enter a number 1‚Äì75.</b></span>`);
        return;
      }
      applyCalledNumber(n);
      $("#calledNum").value = "";
      $("#calledNum").focus();
    });
    $("#calledNum").addEventListener("keydown", (e)=>{ if(e.key==="Enter") $("#btnCall").click(); });

    function refreshCalledPill(){
      const p = document.getElementById("pillCalled");
      if(p) p.textContent = `${state.calledHistory.length} called`;
    }

    function refreshHistory(){
      const h = $("#history");
      h.innerHTML = "";
      refreshCalledPill();
      state.calledHistory.forEach(s=>{
        const chip = el("div",{className:"chip", textContent:s});
        chip.addEventListener("click", ()=>applyCalledNumber(parseInt(s,10)));
        h.appendChild(chip);
      });
    
      try{ renderPlayStack(); }catch(_){ }
}

    $("#btnUndo").addEventListener("click", ()=>{
      if(state.calledHistory.length===0) return;
      const removed = state.calledHistory.shift();
      for(const card of state.cards){ card.marked = new Set(); }
      for(const s of state.calledHistory){
        const n = parseInt(s,10);
        for(const card of state.cards) markNumberOnCard(card, n);
      }
      refreshHistory();
      renderBoard();
      drawSelected();
      $("#btnUndo").disabled = state.calledHistory.length===0;
      setStatus(`Undid called number <b>${removed}</b>.`);
      saveSession(true);
    });

    // ===== Voice input (Web Speech API) =====
    const VoiceRec = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognizer = null;
    let voiceListening = false;

    function isVoiceSupported(){ return !!VoiceRec; }
    function setVoiceButton(){
      const b = $("#btnVoice");
      if(!b) return;
      if(!isVoiceSupported()){
        b.disabled = true;
        b.textContent = "üé§ Voice (not supported)";
        return;
      }
      b.disabled = false;
      b.textContent = voiceListening ? "üõë Stop" : "üé§ Voice";
    }

    function parseSpokenNumber(text){
      if(!text) return null;
      const t = text.toLowerCase().trim();
      const m = t.match(/(\d{1,2})/);
      if(m){
        const n = parseInt(m[1], 10);
        return (n>=1 && n<=75) ? n : null;
      }
      const ones = {"zero":0,"one":1,"two":2,"three":3,"four":4,"five":5,"six":6,"seven":7,"eight":8,"nine":9,"ten":10,"eleven":11,"twelve":12,"thirteen":13,"fourteen":14,"fifteen":15,"sixteen":16,"seventeen":17,"eighteen":18,"nineteen":19};
      const tens = { "twenty":20,"thirty":30,"forty":40,"fifty":50,"sixty":60,"seventy":70 };
      const cleaned = t.replace(/\b(number|no\.?|call|called|it is|its|bingo|letter|b|i|n|g|o)\b/g, " ").replace(/\s+/g," ").trim();
      if(ones[cleaned] != null){
        const n = ones[cleaned];
        return (n>=1 && n<=75) ? n : null;
      }
      const parts = cleaned.split(" ").filter(Boolean);
      if(parts.length === 2 && tens[parts[0]] != null && ones[parts[1]] != null){
        const n = tens[parts[0]] + ones[parts[1]];
        return (n>=1 && n<=75) ? n : null;
      }
      if(parts.length === 1 && tens[parts[0]] != null){
        const n = tens[parts[0]];
        return (n>=1 && n<=75) ? n : null;
      }
      return null;
    }

    function startVoice(){
      if(!isVoiceSupported()){
        setStatus(`<span style="color:var(--warn)"><b>Voice input isn‚Äôt supported</b> in this browser. Try Chrome/Edge.</span>`);
        return;
      }
      recognizer = new VoiceRec();
      recognizer.lang = "en-CA";
      recognizer.interimResults = true;
      recognizer.continuous = true;

      recognizer.onstart = () => {
        voiceListening = true;
        setVoiceButton();
        setStatus(`üé§ Listening‚Ä¶ say a number (1‚Äì75). Example: ‚Äútwenty one‚Äù or ‚Äú47‚Äù.`);
      };
      recognizer.onerror = (e) => {
        voiceListening = false;
        setVoiceButton();
        setStatus(`<span style="color:var(--warn)"><b>Voice error:</b></span> ${e.error || "unknown error"}.`);
      };
      recognizer.onend = () => {
        voiceListening = false;
        setVoiceButton();
        setStatus(`Voice stopped. Tap üé§ Voice to start again.`);
      };
      recognizer.onresult = (event) => {
        const r = event.results[event.results.length - 1];
        const best = (r && r[0] && r[0].transcript) ? r[0].transcript : "";
        const n = parseSpokenNumber(best);
        if(n != null){
          if(r.isFinal) applyCalledNumber(n);
          else setStatus(`üé§ Heard: <b>${best}</b> ‚Üí (possible: ${n}) ‚Ä¶`);
        } else if(r.isFinal && best.trim()){
          setStatus(`üé§ Heard: <b>${best}</b> ‚Äî couldn‚Äôt find a number 1‚Äì75.`);
        }
      };
      recognizer.start();
    }

    function stopVoice(){ try{ if(recognizer) recognizer.stop(); } catch(_) {} }

    $("#btnVoice").addEventListener("click", ()=>{
      if(voiceListening) stopVoice();
      else startVoice();
    });
    setVoiceButton();

    
    // ===== New Game (clear marks + history, keep cards) =====
    $("#btnClearGame").addEventListener("click", ()=>{
      state.calledHistory = [];
      for(const card of state.cards){
        card.marked = new Set();
      }
      refreshHistory();
      renderBoard();
      drawSelected();
      $("#btnUndo").disabled = true;
      setStatus("New game started. Cards retained, marks cleared.");
      saveSession(true);
    });

    // ===== Reset =====
    
    $("#btnClearAll").addEventListener("click", ()=>{
      stopVoice();
      state.cards = [];
      state.selectedId = null;
      state.calledHistory = [];
      loadedImg = null;
      refreshThumbs();
      refreshHistory();
      renderBoard();
      drawEmpty();
      $("#selLabel").textContent = "None";
      $("#btnUndo").disabled = true;
      setStatus("Reset complete. Scan a card to begin.");
      saveSession(true);
    });

    // Save/Recall buttons
    $("#btnSaveSession").addEventListener("click", ()=>saveSession(false));
    $("#btnLoadSession").addEventListener("click", ()=>loadSession());
    $("#btnClearSaved").addEventListener("click", ()=>{ if(confirm("Clear saved cards?")) clearSaved(); });

    
    // ===== Stacked View =====
    let stackedView = false;

    function buildBoardForCard(card, idx){
      const wrap = document.createElement("div");
      wrap.className = "stackCard";

      const top = document.createElement("div");
      top.className = "stackLabel";
      const left = document.createElement("span");
      left.innerHTML = `<b>Card ${idx+1}</b>`;
      const right = document.createElement("span");
      const markCount = card.marked ? card.marked.size : 0;
      right.textContent = card.grid ? `OCR ‚úì ¬∑ ${markCount} marks` : `OCR ‚Äî ¬∑ ${markCount} marks`;
      top.append(left, right);
      wrap.appendChild(top);

      const board = document.createElement("div");
      board.className = "stackBoard";

      const grid = card.grid || Array.from({length:5}, ()=>Array(5).fill(null));
      const ranges = [[1,15],[16,30],[31,45],[46,60],[61,75]];

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          const cell = document.createElement("div");
          cell.className = "cell";

          if(r===2 && c===2){
            cell.classList.add("free","marked");
            cell.textContent = "FREE";
            const sm = document.createElement("small");
            sm.textContent="(center)";
            cell.appendChild(sm);
          } else {
            const n = grid[r][c];
            cell.textContent = n==null ? "‚Äî" : String(n);
            cell.classList.add("editable");
            if(n!=null){
              const [lo,hi]=ranges[c];
              if(n<lo || n>hi) cell.classList.add("sus");
            }
            if(n!=null && card.marked && card.marked.has(String(n))) cell.classList.add("marked");
            if(n==null && card.grid) cell.classList.add("bad");

            // Tap-to-edit works here too
            cell.addEventListener("click", ()=>{
              const current = (grid[r][c]==null) ? "" : String(grid[r][c]);
              const val = prompt(`Edit Card ${idx+1} square (leave blank to clear):`, current);
              if(val === null) return;
              const vv = val.trim();
              let newNum = null;
              if(vv){
                const parsed = parseInt(vv,10);
                if(Number.isFinite(parsed) && parsed>=1 && parsed<=75) newNum = parsed;
              }
              card.grid[r][c] = newNum;

              // Rebuild marks for this card based on history
              card.marked = new Set();
              for(const s of state.calledHistory){
                markNumberOnCard(card, parseInt(s,10));
              }

              // Refresh both views
              refreshThumbs();
              renderBoard();
              drawSelected();
              renderStackedView();
              saveSession(true);
            });
          }

          board.appendChild(cell);
        }
      }

      wrap.appendChild(board);
      return wrap;
    }

    function renderStackedView(){
      const cont = document.getElementById("stackContainer");
      cont.innerHTML = "";
      if(!stackedView) return;

      if(state.cards.length === 0){
        const msg = document.createElement("div");
        msg.className = "hint";
        msg.textContent = "No cards yet. Scan a card first.";
        cont.appendChild(msg);
        return;
      }

      state.cards.forEach((card, idx)=>{
        cont.appendChild(buildBoardForCard(card, idx));
      });
    }

    $("#btnStackView").addEventListener("click", ()=>{
      stackedView = !stackedView;

      // Hide the image canvas area in stacked mode
      document.getElementById("canvasWrap").style.display = stackedView ? "none" : "block";
      document.getElementById("overlay").style.display = stackedView ? "none" : "block";
      document.getElementById("stackContainer").style.display = stackedView ? "block" : "none";
      const st = document.getElementById("stackTitle");
      if(st) st.style.display = stackedView ? "block" : "none";
      const sba = document.getElementById("singleBoardArea");
      if(sba) sba.style.display = stackedView ? "none" : "block";

      // Crop/OCR buttons only make sense in single view
      $("#btnCropMode").style.display = stackedView ? "none" : "inline-block";
      $("#btnReadOCR").style.display = stackedView ? "none" : "inline-block";
      $("#btnRetryOCR").style.display = stackedView ? "none" : "inline-block";

      $("#btnStackView").textContent = stackedView ? "‚¨Ö Single View" : "üìã Stacked Boards";
      $("#selLabel").textContent = stackedView ? "All cards (boards)" : "Single";

      renderStackedView();
    });

    // Re-render stacked view when numbers are called
    const _applyCalledNumber = applyCalledNumber;
    applyCalledNumber = function(n){
      _applyCalledNumber(n);
      if(stackedView) renderStackedView();
    };

    // ===== Play Stack (always visible) =====
    function buildPlayStackCard(card, idx){
      const wrap = document.createElement("div");
      wrap.className = "playStackCard";

      const hdr = document.createElement("div");
      hdr.className = "playStackHdr";
      const left = document.createElement("span");
      left.innerHTML = `<b>Card ${idx+1}</b>`;
      const right = document.createElement("span");
      const mc = card.marked ? card.marked.size : 0;
      right.textContent = `${card.grid ? "OCR ‚úì" : "OCR ‚Äî"} ¬∑ ${mc} marked`;
      hdr.append(left,right);
      wrap.appendChild(hdr);

      const board = document.createElement("div");
      board.className = "playStackBoard";

      const grid = card.grid || Array.from({length:5},()=>Array(5).fill(null));
      const ranges = [[1,15],[16,30],[31,45],[46,60],[61,75]];

      for(let r=0;r<5;r++){
        for(let c=0;c<5;c++){
          const cell = document.createElement("div");
          cell.className = "cell";
          if(r===2 && c===2){
            cell.classList.add("free","marked");
            cell.textContent = "FREE";
            const sm=document.createElement("small"); sm.textContent="(center)";
            cell.appendChild(sm);
          } else {
            const n = grid[r][c];
            cell.textContent = (n==null) ? "‚Äî" : String(n);
            if(n!=null){
              cell.classList.add("editable");
              const [lo,hi]=ranges[c];
              if(n<lo || n>hi) cell.classList.add("sus");
              if(card.marked && card.marked.has(String(n))) cell.classList.add("marked");
            } else if(card.grid){
              cell.classList.add("bad");
            }
          }
          board.appendChild(cell);
        }
      }

      wrap.appendChild(board);
      return wrap;
    }

    function renderPlayStack(){
      const cont = document.getElementById("playStack");
      if(!cont) return;
      cont.innerHTML = "";
      if(!state.cards || state.cards.length===0){
        cont.innerHTML = `<div class="hint">No cards yet. Scan a card to begin.</div>`;
        return;
      }
      state.cards.forEach((card, idx)=>{
        cont.appendChild(buildPlayStackCard(card, idx));
      });
    }



    // ===== Init =====
        
    refreshThumbs();
    refreshHistory();
    renderBoard();
    drawEmpty();
    updateSavedPill();
    (async()=>{ try{ const s = await dbGet(SESSION_KEY); if(s && s.cards && s.cards.length){ await loadSession(); } }catch(_){} })();
    window.addEventListener("resize", ()=>drawSelected());
  </script>
</body>
</html>
